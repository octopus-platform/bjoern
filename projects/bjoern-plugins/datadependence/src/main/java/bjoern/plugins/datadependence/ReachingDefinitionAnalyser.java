package bjoern.plugins.datadependence;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.gremlin.java.GremlinPipeline;

import java.util.*;
import java.util.function.Function;

class ReachingDefinitionAnalyser {
	private static final String[] CFLOW_LABEL = {
			"NEXT_INSTR",
			"NEXT_INSTR_TRANSITIVE"
	};
	// a function computing the set of definitions generated by a vertex
	private final Function<Vertex, Set<Definition>> gen;
	// a function computing the set of definitions killed by a vertex
	private final Function<Vertex, Set<Definition>> kill;
	private Map<Vertex, Set<Definition>> out;

	/**
	 * A pair of location and identifier representing a definition where
	 * location is a vertex in a control flow graph and identifier an
	 * arbitrary object. The pair (location, identifier) expresses that the
	 * identifier is modified at this location.
	 */
	static class Definition {
		private final Vertex location;
		private final Object identifier;

		Definition(Vertex location, Object identifier) {
			this.location = location;
			this.identifier = identifier;
		}

		public Vertex getLocation() {
			return location;
		}

		public Object getIdentifier() {
			return identifier;
		}

		@Override
		public boolean equals(Object object) {
			if (!(object instanceof Definition)) {
				return false;
			}
			Definition definition = (Definition) object;
			return location.equals(definition.location)
					&& identifier.equals(definition.identifier);
		}

		@Override
		public int hashCode() {
			int hashCode = 17;
			hashCode = 31 * hashCode + location.getId().hashCode();
			hashCode = 31 * hashCode + identifier.hashCode();
			return hashCode;
		}

		@Override
		public String toString() {
			return identifier.toString() + "@" + location.getId().toString();
		}
	}

	/**
	 * Creates a new reaching definition analyser.
	 *
	 * @param gen
	 * 		a function computing the set of definitions generated by a vertex
	 * @param kill
	 * 		a function computing the set of definitions killed by a vertex.
	 */
	ReachingDefinitionAnalyser(
			Function<Vertex, Set<Definition>> gen,
			Function<Vertex, Set<Definition>> kill) {
		this.gen = gen;
		this.kill = kill;
	}

	Map<Vertex, Set<Definition>> analyse(Vertex entry) {
		this.out = new HashMap<>();
		List<Vertex> nodes = getAllNodesInReversePostOrder(entry);
		boolean changed = true;
		while (changed) {
			changed = false;
			for (int i = 0; i < nodes.size(); i++) {
				Vertex vertex = nodes.get(i);
				Set<Definition> in = getIn(vertex);
				Set<Definition> outNew = computeOut(vertex, in);
				Set<Definition> outOld = getOut(vertex);
				if (!outNew.equals(outOld)) {
					this.out.put(vertex, outNew);
					changed = true;
				}
			}
		}
		return collectReachingDefinitions();
	}

	private Map<Vertex, Set<Definition>> collectReachingDefinitions() {
		Map<Vertex, Set<Definition>> reachingDefinitions = new HashMap<>();
		for (Vertex vertex : out.keySet()) {
			Set<Definition> definitions = new HashSet<>();
			for (Vertex predecessor : vertex.getVertices(Direction.IN,
					CFLOW_LABEL)) {
				definitions.addAll(getOut(predecessor));
			}
			reachingDefinitions.put(vertex, definitions);
		}
		return reachingDefinitions;
	}

	private LinkedList<Vertex> getAllNodes(Vertex entry) {
		LinkedList<Vertex> worklist = new LinkedList<>();
		GremlinPipeline<Vertex, Vertex> pipe = new GremlinPipeline<>();
		pipe.start(entry)
		    .as("loop")
		    .out(CFLOW_LABEL)
		    .dedup()
		    .simplePath()
		    .loop("loop", argument -> true, argument -> true);
		for (Vertex vertex : pipe) {
			worklist.add(vertex);
		}
		return worklist;
	}

	private List<Vertex> getAllNodesInReversePostOrder(Vertex entry) {
		Deque<Vertex> stack1 = new LinkedList<>();
		List<Vertex> stack2 = new LinkedList<>();
		stack1.push(entry);
		while (!stack1.isEmpty()) {
			Vertex root = stack1.pop();
			stack2.add(root);
			for (Vertex child : root.getVertices(Direction.OUT,
					CFLOW_LABEL)) {
				if (stack1.contains(child) || stack2.contains(child)) {
					continue;
				}
				stack1.push(child);
			}
		}
		return stack2;
	}

	private Set<Definition> getIn(Vertex vertex) {
		Set<Definition> in = new HashSet<>();
		for (Vertex predecessor : vertex.getVertices(Direction.IN,
				CFLOW_LABEL)) {
			in.addAll(getOut(predecessor));
		}
		return in;
	}

	private Set<Definition> getOut(Vertex predecessor) {
		Set<Definition> out = this.out.get(predecessor);
		if (null == out) {
			out = getGenSet(predecessor);
		}
		return out;
	}

	private Set<Definition> computeOut(Vertex vertex, Set<Definition> in) {
		Set<Definition> out = new HashSet<>();
		Set<Definition> kill = getKillSet(vertex);
		Set<Definition> gen = getGenSet(vertex);
		out.addAll(in);
		out.removeAll(kill);
		out.addAll(gen);
		return out;
	}

	private Set<Definition> getGenSet(Vertex vertex) {
		return this.gen.apply(vertex);
	}

	private Set<Definition> getKillSet(Vertex vertex) {
		return this.kill.apply(vertex);
	}

}
